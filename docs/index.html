<!DOCTYPE html>
<html>
  <head>
    <title>2017/06 Docker 導入会</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source" style="visibility: hidden">
class: center, middle

# 2017/06 Docker 🐳 導入会

by Kenji Saitou

---

# 今日やること

* Motivation
    * 我々は何に困っているのか？
* Virtue
    * 我々の美徳、目指すところは何か？
* Docker is
    * 何？
* Docker is **NOT**
    * 何？
* Let's use
    * Docker 🐳

---

# 今日ターゲットにする人

* 新人のみなさん
* Docker初心者のみなさん
* 高度なトピックはやりません！

---

class: center, middle

# Motivation

我々は何に困っているのか？

![motivation](motivation.png)

---

## 我々は何に困っているのか？

* 一言で言えばアプリケーションのデプロイにまつわるあれこれ

---

## スノーフレークサーバー ⛄

* https://martinfowler.com/bliki/SnowflakeServer.html
* 度重なる構成変更で状態が降り積もったサーバのこと
* 小さな更新などを繰り返しているうちに、もう二度と同じサーバを作れなくなる
    * 再現性がない
    * そもそも今何が入っているかわからない ＼(^o^)／
* 継ぎ足しまくった秘伝のタレ、秘伝の手順書（最新版は不在）

---

## 不完全なサーバセットアップ

* たとえば、 😃 アプリ開発チーム と 😃 サーバ構築チーム（インフラ基盤）が別れているケース
    * アプリがなぜか動かない
        * あるはずのディレクトリがない (´；ω；｀)
        * パーミッションもオーナーもおかしい (´；ω；｀)
        * シンボリックリンクの配置がおかしい (´；ω；｀)
        * 構築チームにこれを📧伝えるの糞ダルい (´；ω；｀)
* **そもそも**
    * アプリケーションに関係する部分はアプリケーションチームがハンドルを握っているべき。（どうやって？）

---

## 低速なプロビジョニング

* サービスのスケールアウトが難しい
    * スケールアウト：マシン台数増 💻 → 💻💻💻💻💻💻
    * スケールアップ：マシン性能増 💻 → ⚡💻⚡
* クラウドを使ってマシンを増やせたとして、アプリを高速に増やせない

---

## ミドルウェアバージョンアップが困難

* 脆弱性が見つかったので、Webサーバを最新版にあげたくなったら？
    * 最新のライブラリに依存するので、OSのアップグレードが必要ですか？
    * 他の同居ソフトが動かなくなるかもしれませんが？
        * もしかして全テストですか？
* 他のモダンソフトウェアがPHP7を要求したら？
    * オールドソフトウェアがPHP5に依存していたら？

---

## 1 OS <=> 1 インスタンス

* `yum -y install xxx-superawesome-package` でよくある構成
    * シングルトン
    * OSのパッケージで配布されるソフトウェアは多くが1インスタンスしか考慮していない
        * Apacheを2つ同じOSで動かせますか？
            * もちろん頑張らないで

---

## ビルド、インストールが困難

* ある依存ライブラリがないと動きません
    * `lib*.so` がないと動きません
    * Graphviz がないと動きません
    * そのライブラリを動かすには、またある依存ライブラリが必要です
* ローカルに動作環境を構築するのが困難です
    * 本番サーバとテストサーバでしか動かないアプリの爆誕
    * 本番サーバで「えいやっ」しないと何がおこるかわからない

---

## アプリの変数がわからない

* どこが可変で、どこが不変？
    * どんなアプリケーションも下記の2種類の領域を持っている。
        * データが変化する領域
            * データベース, データ書き出し用のディレクトリ, テンポラリディレクトリ, ログ, 外部連携
        * データが変化しない領域
            * アプリケーションコード, 一部の構成
    * レガシーなアプリほど、これらが全てあやふや。
* 何がコントロールできる変数？
    * どこをいじればアプリの動作を変えられるのか不明
    * データベースサーバの場所を移動したいんだけど、どのファイル書き換えればいいの？

---

class: center, middle

# Virtue

我々の美徳、目指すところは何か？

![virtue](./virtue.png)

---

## DRY

* [DRY](https://ja.wikipedia.org/wiki/Don%27t_repeat_yourself) - Don't Repeat Yourself
    * 人間さまは高度なタスクをやる
    * 機械の前に座って機械ができることをやるのは愚かである
    * 簡単、自動で同じことを繰り返せること
        * 同じサーバなら、いつでも、すぐ、自動で作れる
    * 車輪の再発明はしない
        * 誰かが作ったサーバ構成を再利用できる
* 集合知
    * 誰かが先に問題を潰している
    * 誰かと同じ問題にぶち当たることができる
    * [Stackoverflow](https://stackoverflow.com/)
    * [Server Fault](https://serverfault.com/)

---

## Immutable

* 状態を持たない
    * 無秩序な状態（state)がもたらすもの、それはカオス
        * 何が入っているかわからないという不安
        * なら最初から状態がなければいい
    * サーバを理解しやすくなる
    * バージョンアップが簡単になる
        * 大事なデータはしかるべきところに入っているという安心感

![immutable](immutable.png)

---

## XXX (whatever you want) as Code

* せめて、プログラマらしく
* とにかく、何でもコードになっていることが正義
* 曖昧さが薄い
* 機械が再現できる
* ドキュメントとしても機能する

---

## Isolation

* 役割が独立/分散していること
    * ログはログサーバ
    * データはデータベース
    * アプリはアプリサーバ
* なんでも一つがたくさんやりすぎない
* マイクロサービス
    * 大きいシステムはこんなことを意識しなくても強制的にチーム単位で分断する力学が働いている

![isolation](isolation.png)

---

## Version Control

* リリースするアプリ、ちゃんとバージョン管理してますか？
    * Git, Subversion, Mercurial
    * 「最新のソースは本番サーバです！！」
      「共有フォルダにあります！」

       ![こいつ最高にアホ](最高にアホ.png)
    * 本番トラブル時のソースコードを復元できますか？

---

## Automated Build

* 中立的な環境でビルドできていますか？CIできてますか？
    * Jenkins, Travis CI, Circle CI など
* そもそもビルドが自動化できていない
    * 手でビルド?! JavaだとGradleとか使おうぜ案件
    * サーバでしかビルドできない？ 構成が特殊すぎてビルドできないプロジェクトは構成のほうがおかしい
    * 「手元のEclipseでコンパイルして差分だけアップロードしてます😁」
    「依存性管理？何それ美味しいの？」

    ![こいつ最高にアホ](最高にアホ.png)
* たかだか人間が手順を間違えただけで惨事になりませんか？

---

## Simple

* スマフォアプリ
    * AppStoreでGET・更新するだけ！
    * アプリのフォルダとか気にする必要なし！
    * 色々隠蔽されており、細かいコントロールを行えないが、
        * コントロールしたい？
        * 勉強したい？
    * セキュア
        * アプリ間は基本的に独立している
            * 無知でも安心して使える
                * **無知でいられる**

**なぜ我々はこう作れないのだろう？**


---

class: center, middle

# Docker

Build, Ship, and Run Any App, Anywhere

![:scale 50%](docker.png)

---

## Docker is 何？

* Docker, Inc. が開発
* [2013年 3月にリリースされてから](https://en.wikipedia.org/wiki/Docker_(software))、続々更新を続けている
* 簡単にいうと、アプリケーションコンテナを作るためのソフト
    * アプリケーションコンテナって何？

---

## アプリケーションコンテナって何？

* 特定のプロセスの空間を独立させたもの
    * プロセス: `ps` コマンドで出てくる、あのプロセスのことです
    * 具体的には…
        * ファイルシステムが親マシンから隔離されています
            * コンテナの中で暴れても親マシンは平気
        * ネットワークが親マシンから隔離されています
            * コンテナ独自のIPアドレスを持ってるし、明示的に親マシンのネットワークとマッピングしないと、外からの通信を受け取れない
        * プロセス空間が親マシンから隔離されています
            * コンテナの中で `ps` しても自分（とその子）しか見えません
            * 親マシンの他のプロセスの情報を盗めません
* プロセスは上げ下げ（開始・停止）できます。
    * プロセスが上がっているとコンテナが _走行中_ (running)
    * プロセスが下がっているとコンテナが _停止中_

---

## 実演: Dockerのインストール (Ubuntu)

VagrantでUbuntu(16.04 - Xenial)を立ち上げ、Dockerをインストールしてみます。VirtualBox必須です。

（別にVagrantでUbuntuを立ち上げずとも、そのままUbuntuをインストールして入れる、とかでも構いません）

```console
# On you machine.

$ cd ./demos
$ vagrant up
$ vagrant ssh
```

```console
# Inside the Ubuntu.

$ sudo -i
% curl -sSL https://get.docker.com/ | sh
% docker version
```

🍺 終わりです 🍺

（普通にaptリポジトリを追加して〜 という手順もあります。）

---

## 実演: Dockerのインストール (Docker Machine) @1

[Docker Machine](https://docs.docker.com/machine/) を使ってDockerが入ったVMを立ち上げてみます。(macOS or Windows) VirtualBox必須です。

1. [Docker Machineをインストール](https://docs.docker.com/machine/install-machine/)する。

 ```console
$ curl -L https://github.com/docker/machine/releases/download/v0.10.0/docker-machine-`uname -s`-`uname -m` >/usr/local/bin/docker-machine && \
chmod +x /usr/local/bin/docker-machine
$ docker-machine version
# 実態はただの単一のバイナリファイルです
 ```

2. 実行する。VirtualBox上に `mydockermachine` というVMがあがります。

 ```console
$ docker-machine create --driver virtualbox mydockermachine # 普通はdefaultにしておくのが無難です
 ```

---

## 実演: Dockerのインストール (Docker Machine) @2

3. `docker` コマンドに認識させる環境変数をロードさせる。

 ```console
$ eval $(docker-machine env mydockermachine)
 ```

4. 以後は **環境変数のおかげで** `docker` コマンドが勝手に `mydockermachine` (リモート) に転送されます。
    * マシンへのSSH接続: `docker-machine ssh`
        * 別にSSHで繋いでからDockerを楽しんでもいい
    * 自マシンとのフォルダの共有: `/Users` フォルダを見ましょう。他に追加したい場合はググれば出てきます。


---

## 実演: Dockerのインストール (for Mac)

1. [Docker for Mac](https://docs.docker.com/docker-for-mac/install/)を入れましょう。
2. 🍺 終わりです 🍺

1. あるいは、これでも問題なしです
```
$ brew cask install docker
```

* 基本的な原理としてはLinux VMを入れてその上でDockerを動かしているに過ぎません
    * これは Docker for Windowsの場合も同じです。(Hyper-V が必要です。)
* VMのコスト、後述するボリュームについてのファイル同期コストなどあるため、Linuxのほうが軽量です

---

## 実演: Dockerで簡単な操作

DockerでUbuntuのbashのコンテナを作って動かしてみます。

```console
$ docker run -ti --rm ubuntu bash
```

* `docker`: Dockerのベースコマンド
* `run`: 「Dockerコンテナをこのイメージ名とコマンドで動かしまーす！」
    * `docker run [オプション] イメージ名 コマンド`
* `-ti`: これがないと tty がくっつかない
* `--rm`: 終了したらコンテナを廃棄してもらう


---

1. 親マシンからこのプロセス見えるかな？　`pstree`
2. 中から外が見えるかな？
    * 中から外のネットワーク見えるかな？
    * 中の `ps` はみえるかな？
    * 外からパケットが来るかな？ (via `apt install -y apache2`)
3. 中で `rm -rf /*` したらどうなるかな？

---

## Dockerイメージって何？ @ 1

* Dockerコンテナはファイルシステムをホスト（親）マシンと分離している
    * ファイルシステムを分離しているので、自分専用のLinux環境が必要だ！

```
# 親マシンのFS

root@ubuntu-xenial:~# ls /
bin   dev  home        lib    lost+found  mnt  proc  run   snap  sys  usr      var
boot  etc  initrd.img  lib64  media       opt  root  sbin  srv   tmp  vagrant  vmlinuz

# DockerイメージのFS

root@22b398a17fff:/# ls /
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr

```

---

## Dockerイメージって何？ @ 2

* Docker Hub(https://hub.docker.com/) で配布しています
    * Linuxまるごとのファイルシステムのスナップショットのようなものを配布したりしている
        * e.g. Ubuntu - https://hub.docker.com/r/library/ubuntu/
        * e.g. CentOS - https://hub.docker.com/_/centos/
* でも、Linuxがまるごと入ってるってやばくね？ （何ギガだよ？）
    * 実際、そこまでヤバくない
        * e.g. CentOS: 70.49MiB
        * e.g. Ubuntu: 38MiB
        * e.g. 激ヤセLinuxの[Alpine](https://hub.docker.com/r/library/alpine/tags/): 2MiB!!!
    * どれも最低限の構成になっている。必要なソフトウェアは自前で入れるか、入っているDockerイメージを使うべし。

---

## Dockerイメージって何？ @ 3

* 自分でも配布できます
    * Docker Hubに置いたり
    * プライベートなレジストリをもって、そこに置いたり
* ほしいアプリの、だいたいあります。
    * Nginx, Jenkins, ElasticSearch, Logstash, Open Tsukubai etc.
* 当然、自分で作れます。普通に作ります。

じゃあ作ってみよう。

---

## 実演: Dockerイメージを作成 @ 1

1. 以下のファイルを `Dockerfile` として保存。

```dockerfile
FROM ubuntu

RUN apt-get update
RUN apt-get install -y python
```

* 解説
    1. `ubuntu` をベースにDockerイメージを作成しまーす
    2. `yum update` を実行したDockerイメージを作成
        * [1] との差分として保存 💾 
    3. `yum install -y python` を実行したDockerイメージを作成
        * [2] との差分として保存 💾 
    4. 🍺 これでPythonの入ったUbuntuイメージの完成!

コマンドを実行するごとに前との差分をどんどん作成、保存していく。
イメージを使うときは差分が全て合成された状態のものを使う。

---

たとえば、下記の2パターンをビルドした場合、

```Dockerfile
FROM ubuntu #1
RUN apt-get update #2
RUN apt-get install -y python #3
```
```Dockerfile
FROM ubuntu #1
RUN apt-get update #2
RUN apt-get install -y perl #4
```

2パターン目の `#1`, `#2` は　1パターン目の  `#1`, `#2` が再利用される。

![:scale 90%](docker-reuse.png)

差分をうまく使ってビルドの高速化、ストレージ専有のスリム化を行っている。

---

## 実演: Dockerイメージを作成 @ 2

2. コマンドを実行してDockerイメージをビルドする

```console
$ docker build -t myimage .

$ docker images | grep myimage
```

* `docker build [-t タグ名] どこのフォルダ(build's context)でビルドするか？`
    * `-t タグ名` は省略可能。ただし、省略した場合はビルド結果を参照するには、自動付与されたハッシュ名を用いるしかなくなる。
    * _どこのフォルダでビルドするか？_ はビルドのコンテキストとなるディレクトリを指定。
        * **ビルドのコンテキストとなるディレクトリ内の資材は基本的にビルド開始時全てDockerデーモンにアップロードされるので注意。**
            * `.dockerignore` ファイルで無視させましょう
        * ビルドコンテキストディレクトリ内のファイルはDockerfile内で参照できます (`COPY`コマンドなど)
        * この仕組みで遠くのDockerデーモンでもビルド可能になっている

---

## 実演: Dockerイメージを実行 @ 1

1. 作成したDockerイメージを実行する
    * 今度は `--rm` (終了時削除) を選ばず実行
    * `--name コンテナ名` を指定して実行

 ```console
$ docker run -ti \
    --name myimagecontiner \
    myimage bash
 ```

2. **Dockerコンテナ `myimagecontiner` が作られて** 、その中に入ることができる。

 ```console
$ which python
$ python
# C-d を押して出ていってください
 ```

---

## 実演: Dockerイメージを実行 @ 2

3. `docker ps -a` コマンドでコンテナを確認することができる。

 ```console
$ docker ps -a # docker ps だと生きているコンテナしか見られない
IMAGE    COMMAND  CREATED        STATUS                    NAMES
myimage  "bash"   4 seconds ago  Exited (0) 3 seconds ago  myimagecontainer
 ```

4. `docker rm` コマンドでコンテナを削除することができる

 ```console
$ docker rm myimagecontainer
$ docker ps -a # 何もでない
 ```

他にも大量にコマンド、オプションはあります。

* https://docs.docker.com/engine/reference/commandline/cli/
* https://docs.docker.com/engine/reference/run/
* `-v` で親マシンのディレクトリをコンテナ内にマップできます
* `-p` で親マシンのポートをコンテナ内にマップできます

---

## Dockerコンテナって何？ @1

* Dockerイメージを実行する時にできるインスタンス
    * 実行時にコンテナとしてプロセス空間の制約を受ける
    * 停止、再開できる

    ```console
$ docker stop myimagecontainer   # SIGTERM
$ docker start myimagecontainer  # bash (run時に指定したコマンド)
    ```

    * 終了(`docker stop`)時は作成したコンテナのプロセスが `SIGTERM` を受け取る
    * 再開時は run 時に指定したコマンドラインが再度実行される

---

## Dockerコンテナって何？ @2

* Dockerイメージ作成と対してかわらない
    * Dockerイメージはファイル差分により管理されていたが、その末端にコンテナというファイル差分が更に追加されるだけ。
    * 別にコンテナをDockerイメージに変換することも可能: `docker commit` コマンド

![:scale 70%](docker-container.png)

---

## Dockerコンテナって何？ @3

* イメージと違って、開始・終了などといった状態がある： `docker ps` コマンド
* しかし気軽に使ったり、消したりすることができる
    * ☠ 逆にいえば、気軽に消せないようなコンテナは作ってはいけない

---

## VM（仮想マシン）にそっくりだね！

* 実際、当初は仮想マシンと対比されることがかなり多かったです
* しかし、全く違うものです
* そもそも Docker on a VM が圧倒的に多い
    * どっちかどうとかいう話ではない　役割が違う
* おそらく自作アプリケーションをDockerイメージにしたい人はいても、VMにしたい人はあまりいないはず

---

| 項目 | VM | 🐳 Docker |
|-|----|-----------|
| 指向性 | OSに対して | OSのプロセスに対して |
| OS | CPUさえあってれば、なんでも動かせる | 基本的にAMD64 Linux |
| ハイパーバイザ | ESXi, Linux (KVM), Windows (Hyper-V), macOS (Parallels), VirtualBox etc. | あえていうならホストマシンのカーネル |
| ストレージ | 大量に必要 | イメージ、コンテナ間を差分管理 |
| 自由度 | 大 | 小 |
| リソース制限 | 自由かつ厳格 | できればいいなあ |
| Intel VT-x | だいたい必要 | 不要 (VM上でも動かせる) |
| 技術 | ハードウェアエミュレーション | ただのプロセス分離 |
| フットプリント | 大 | 小 |
| 気軽さ | 😭 | 😁 ＜立ち上がりが速い！ |

**ただ、はっきりいって両者を真面目に比較している時点で正気じゃありません。**

---

## Dockerはただのツールじゃない

* 当初はLinux上でDockerイメージとコンテナを作るだけのソフトでした
    * しかし、月日が経つにつれ、便利機能、便利ツールが充実してきてソフトというよりはプラットフォームと呼んだほうがよくなってきている
        * 単純なソフトウェアとして、捉えてはいけない
    * 蓄積された知見量も多く、何か問題にひっかかっても、誰かがひっかかっている
* [Windows Server 2016](https://www.docker.com/docker-windows-server) でも動く (LinuxではなくWindowsソフトが)
    * ARM でも動く
    * 〜〜〜 でDockerが動くと言った場合、単に小さな AMD 64bit Linux のVM上で動くというケースが多い

---

## Dockerの周辺ツール

* Docker Compose
* Docker Machine
* Docker for Mac / Docker for Windows
* Swarm
* Kubernetes

## コミュニティ

* Docker Hub
* Github
    * だいたいのプロジェクトがDockerfileを備えている
        * あのマストドンにも[ありました](https://github.com/tootsuite/mastodon/blob/master/Dockerfile)
* 書籍
* 認知度

---

## 注意

* 今回紹介したDockerコマンドは近々コマンド名など変更される予定があります。

## Thanks

* VSCode
    * https://code.visualstudio.com/
* Ramark
    * https://github.com/gnab/remark
    * HTMLの中にMarkdown書くだけで勝手にスライドにしてくれるすごいやつ
* https://en.wikipedia.org/wiki/Docker_(software)

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>

    remark.macros.scale = function (percentage) {
        var url = this;
        return '<img src="' + url + '" style="width: ' + percentage + '" />';
    };

      var slideshow = remark.create();
    </script>
  </body>
</html>